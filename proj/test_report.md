# Test report
We divided the group in the beginning so that half the group started to work on the tests and the other started working with the implementation. The ones that started working on the tests decided that the functions that should be tested by the unit tests were the ones that were given in the header file, `refmem.h`. The division of the test functions in the test group was fairly straigth forward and we just picked the ones that we liked.  

Initially the work on the tests was slow while the implementation progressed rather fast. This resulted in that, when the implementation was done, the unit test wasn't. Thus, we had to test parts of the implementation manually. After the implementation got finished, work on the test sped up, probably because we had some additional code to look at when we wrote the tests. However some miscommunication between the people working on the test and the implementation led to that when the implementation group continued working on newer versions of the implementation, the test where still written for the older version. This also was a part of the tests being delayed.    

In the end we did manage to make tests for all functions in the header file except for `deallocate()`. The task of `deallocate()` is to free objects and we concluded that if we write a test to find out if the free was a success, we would get a segmentation fault which we know wouldn't give us a possible way to get a test result. An other function that we thought was tricky to test was `shutdown()` because it's functionality is similar to `deallocate()`. However if we set the freed objects to `NULL` in the end of the `shutdown()` method, that is something we can test and see if the object is indeed `NULL` after `shutdown()`. 

Because of the delays in the test group the integration group did the integration testing. Afterwards this decision make sense and we should have divided the work better from the beginning. The integration tests was done by checking for memory leakage when the garbage collector was integrated with the storage code. This was done because we reasoned that assuming that the garbage collector was already tested by the unit tests and the storage is tested before when that assignment was done, a memory test was a sufficent test of collaboration between modules. These tests for memory leakage was done through the process of developing the final product of the garbage collector. More specifically, these tests was performed by having an input file for valgrind which gave us an automated run for memory leakage.     

Automated regression testing was something that was not used during this project. This is due to the fact that the test group didn't deliver as planned and that when the unit test was finally done, so was the implementation. This also led to that the implementation group hade do manually test their new implementations to see if the garbage collector still had the same functionality.

An other thing that wasn't used during the process of this project is the use of GitHub's issue page. This is due to the fact that it was simply forgotten. This resulted in that we don't have any documentation bugs that we faced during the process. But we still remember some of them. 

The biggest bug that occured during the work on the implementation was a large memoryleakage that was hard to find. Even when only one int was allocated and directly freed the program still leaked thousands of bytes. This was later discovered to be a forgotten line of `printf` that has been used to find another bug.

Another bug that was faced by the test group was that `get_cascade_limit()` always returned the initial value of the cascade limit. This led to us thinking that `set_cascade_limit()` was not working correctly and quite a lot of time was put into trying to fix `set_cascade_limit()`. This bug was however due to `get_cascade_limit()` resetting the cascade limit to the initial value.

![Coverage](coverage.png)
