#Test report
We divided the group in the beginning so that half the group started to work on the tests and the other started working with the implementation. The ones that started working on the tests for the project decided that the methods that should be tested by the unit tests is the ones that was given in the header file of refmem. The division of the test methods in the test group was pretty straigth forward and we just picked the ones that we liked.  
In the beginning the work on the tests was slow and the work with the implementation was pretty fast. It led to that when the implementation was done, the unit test wasn't. We therefor had to test parts of the implementation manually. After the Implementation got done did the work on the test sped up, probably because we had some code to look at when we wrote the tests. However some miscommunication between the people working on the test and the implementation led to that when the implementation group continued working on newer versions of the implementation, the test where still written for the older version. This also was a part of the tests being delayed.    

In the end did we make tests for all methods in the header file except for deallocate. Deallocates task is to free objects. We concluded that if we write a test to find out if the free was a success, we would get a segfault which we know wouldn't give us a possible way to get a test result. An other method that we thought was tricky to test was shutdown because it's functionality is similar to deallocate. However if we set the freed objects to NULL in the end of the shutdown method so that is something we test and see if the object is NULL after shutdown. 

Because of the delays in the test group the integration group did the integration testing. Afterwards this decision make sense and we should have divided the work better from the beginning. The integration tests was done by checking for memory leakage when the garbage collector was integrated with the storage code. This was done because we thought that the garbage collector was already tested by the unit test and the storage is tested before when that assignment was done. These tests for memory leakage was done through the process of developing the final product of hte garbage collector. More specifically, these tests was performed by having an input file for valgrind which gave us an automated run for memory leakage.    

Automated regression testing was something that was not used during this project. This is due to the fact that the test group didn't deliver as planned and that when the unit test was finally done, so was the implementation. This also led to that the implementation group hade do manually test their new implementations to see if the garbage collector still had the same functionality.

An other thing that wasn't used during the process of this project is the use of GitHub's issue page. This is due to the fact that it was simply forgotten. This resluts in that we don't have any documentation bugs that we faced during the process. But we still remember some of them. The biggest bug that occured during the work on the implementation was a large memoryleakage that was hard to find. Even when only one int was allocated and directly freed the program still leaked thousands of bytes. This was later discovered to be a forgotten line of printf that has been used to find another bug.
Another bug that was faced by the test group was that get_cascade_limit always returned the initial value of the cascadelimit. This led to us thinking that set_cascade_limit was not working correctly and quite a lot of time was but into trying to fix set_cascade_limit. This bug was however due to that get_cascade_limit reset the cascade limit to the initial value.
